module br.com.structtechnology

# Comment single line test

#*
    Comment multline test 1
    ~!@#$%Ë†&*()_+=-{}[]|\:;'`/.,<>?
    Comment multline test 2 #*
    Comment multline test 3 #
    Comment multline test 4 #*
    Comment multline test 5
*#

interface IPerson(): # for parsing optimization purposes, if you maintain the structure of the statement you'll be avoiding LOOKAHEAD's in LR parsers
    public:
        int burn_year() # the same
        str set_name(str name, int age)

from dux.datetime import date

public:
    const str name = "Matheus Santos" # It's a comment
    real valor = 0.0
    double dv#* This comment must

    be ignorated *#alor = 0.0
    list names = []
    dict people = {
        'nome': name
    }
    tuple coordinates = [22,23]

class Hand():
    pass

#*doc!markdown
    Class Documentation test using markdown
    =======================================

    - Item 1
    - Item 2
*#
class Person(public object, private IPerson): # it's more dynamic if you let the consumer of your class to decide if it will be exposed, like in C++
    public:
        # Would add constructor and destructor... Specially, destructor since will help avoid garbage collectors and will enable smart pointers
        Person():
            this.age = 0
            this.hand = new Hand()
        ~Person():
            delete this.hand

    private: # prefer C++ like scoping
        int age = 33
        bool live = false
        Hand hand;

    protected:
        void init():
            super.init()
            this.name = name

    public:
        #*doc
            burn_year: Calc the burn year
        *#
        int burn_year():
            int year = date.today().year
            return year - this.age

        int age() get: # again, for parsing purposes would apply modifiers at the end
            return this.age

        void age(int value) set:
            this.age = value

class Animal():

    int age = 2

    Animal(str name):
        this.name = name

    int burn_year():
        int year = date.today().year
        return year - this.age

void main():
    Person person = new Person()
    println(person.burn_year)

    Animal animal = new Animal()
    println(animal.burn_year)

    assert(name+age == 'Matheus Santos33')

    println('Hi, my name is {0} and I\'m {1} years old' % [name, age])

    str text = 'Hi, my name is {0} and I\'m {1} years old' % [name, age]

    str text = 'Hi, my name is {name} and I\'m {age} years old' % {
        'name': name,
        'age': age
    }

    int a = 1,
        b = 2,
        total = 0

    total = a + b

    assert(total==3)

    total++

    assert(total==4)

    total--

    assert(total==3)

    println(total)

    for int i in range(10):
        println(i)

    for int i in 0..<10:
        println(i)

    for int i = 0, i < 10, i++:
        println(i)

    int i = 0
    
    do:
        i++
    while i<100
    
    switch(i):
        case 1:
            println('It is the number one')
            break
        case 'Matheus':
            println('It is a person!')
            break
        default:
            println('I don\'t know')

    try:
        &label1 while true:
            int i = 0
            println(i)
            i++
            while i < 10:
                if i == 5:
                    break &label1
                else:
                    j++
            if i == 10:
                break
    except:
        goto &error

    else:
        println('Didn\'t use the break to the label')

    &error:
        println('error')
